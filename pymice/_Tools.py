#!/usr/bin/env python
# encoding: utf-8
"""
_Tools.py

Copyright (c) 2012-2015 Laboratory of Neuroinformatics. All rights reserved.
"""
from datetime import datetime
import time
import warnings
from math import modf

import numpy as np
#import matplotlib.dates as mpd
#import matplotlib.pyplot as plt
import matplotlib.mlab as mmlab


def timeString(x, tz=None):
  return datetime.fromtimestamp(x, tz).strftime('%Y-%m-%d %H:%M:%S.%f%z')


def deprecated(message, warningClass=DeprecationWarning, stacklevel=1):
  warnings.warn(message, warningClass, stacklevel=stacklevel + 2)


def ensureFloat(x):
  """
  Convert x to float if possible.

  Accept ',' used as a decimal mark.

  Convert '' to None.
  """
  if isinstance(x, basestring):
    if x == '':
      return None

    return float(x.replace(',', '.'))

  if x is not None:
    return float(x)


def ensureInt(x):
  """
  Convert x to int if possible.

  Convert '' to None.
  """
  if x == '' or x is None:
    return None

  return int(x)


def hTime(t):
  """
  Convert timestamp t to a human-readible string.
  """
  dec, integer = modf(t)
  return time.strftime("%Y-%m-%d %H:%M:%S" + ('%01.3f' % dec)[1:],
                       time.localtime(integer))

EPOCH = datetime(1970,1,1)
UTC_OFFSET = time.mktime(EPOCH.timetuple())

def convertTime(tStr):
  tSplit = tStr.replace('-', ' ').replace(':', ' ').split()
  subSec = float(tSplit[5]) if len(tSplit) == 6 else 0.
  return (datetime(*map(int, tSplit[:5])) - EPOCH).total_seconds() + subSec + UTC_OFFSET # a hook for backward compatibility

  #try:
  #  return time.mktime(time.strptime(tSplit[0], '%Y-%m-%d %H:%M:%S'))\
  #         + subSec

  #except ValueError:
  #  return time.mktime(time.strptime(tSplit[0], '%Y-%m-%d %H:%M'))\
  #         + subSec

class ExcludeMouseData(object):
  """
  A class for storing information about excluded data segments / modalities
  """
  def __init__(self, **kwargs):
    self.starttime = kwargs.pop('starttime', 0)
    self.endtime = kwargs.pop('endtime', 0)
    self.logtype = kwargs.pop('logtype', None) 
    # logtype should be one of: Lickometer, Presence, Corner, Cage, SocialBox, 
    # AnimalGate, ???
    self.notes = kwargs.pop('notes', None)
    
    # The rest of the fields goes to the location dictionary
    self.location = {}
    for key in ['cage', 'corner', 'side']:
      self.location[key] = kwargs.pop(key, None)
    for key in kwargs:
      self.location[key] = kwargs.pop(key, None)
          
  def __repr__(self):
    ss = '\n'.join(['Exclude %s from %s to %s' %(self.logtype, 
                    time.strftime('%d.%m %H:%M', 
                            time.localtime(self.starttime)), 
                    time.strftime('%d.%m %H:%M', 
                            time.localtime(self.endtime))),
                   'in location: %s.' %(', '.join([key + ' = ' + str(value)
                   for key, value in self.location.iteritems()]))])
    if self.notes is not None:
      ss = '\n'.join([ss, '', 'Notes:', self.notes])

    return ss


class ILogAnalyzer(object):
  def __call__(self, md):  
    raise NotImplementedError("Virtual method called")

class LickometerLogAnalyzer(ILogAnalyzer):
  def __init__(self, threshold_short=3, threshold_med=None):
    self.threshold_short = threshold_short
    if threshold_med is None:
      self.threshold_med = 4 * self.threshold_short

    else:
      self.threshold_med = threshold_med

    self.med_bin = 3600. # 1-hour bins for final processing
    self.short_bin = 900.
    self.notes = '\n'.join(['Generated by LickometerLogAnalyzer with ',
                          'threshold_short = %3.2f, threshold_med= %3.2f' 
                          %(self.threshold_short, self.threshold_med), '', ''])
  
  def __call__(self, md):
    # TODO Make sure we do not get strange starting and ending times
    # resulting from strange bins
    results = []
    for cage in md.cages: 
      alltimes = md.getstarttimes(md.cages[cage])
      for side in ['1', '2', '3', '4', '5', '6', '7', '8']:
        events = [tm for tm, typ, cn, cg, ltype, sd in zip(
              md.data['Log_DateTime'], md.data['Log_LogNotes'], md.data['Log_Corner'],
              md.data['Log_Cage'], md.data['Log_LogType'],
              md.data['Log_Side'])
              if ltype == 'Lickometer' and cg == cage and sd == side]
        tt = np.array(map(convertTime, events))
        if len(tt) > 0:
          med_bins = np.arange(tt.min(), tt.max() 
                     + self.med_bin + 0.1, self.med_bin)
          med_hist = np.histogram(tt, bins=med_bins)[0]
          # short_bins = np.arange(tt.min(), tt.max() 
          #              + self.short_bin, self.short_bin)
          # short_hist = np.histogram(tt, bins=short_bins)[0]
          if np.all(med_hist <= self.threshold_med): 
            # and np.all(short_hist <= self.threshold_short):
            pass

          else:
            idcs = mmlab.contiguous_regions(med_hist > self.threshold_med)
            # print idcs
            for tstartidx, tstopidx in idcs:
              tstart = med_bins[tstartidx]
              tstop = med_bins[tstopidx]
              # print tstart, tstop
              results.append(ExcludeMouseData(starttime=tstart,
                      endtime=tstop, logtype='Lickometer',
                      cage=cage, side=side,
                      notes=str(sum(med_hist[tstartidx:tstopidx])) 
                      + ' cases. ' + self.notes))

    return results 

class OldLogAnalyzer(ILogAnalyzer):
  """Moved here from miceloader2, just prints warnings and errors"""
  def __call__(self, md):
    try:
      errors = [(date, note, logtype) for date, note, category, logtype in 
            zip(md.data['Log_DateTime'], md.data['Log_LogNotes'], 
            md.data['Log_LogCategory'],
            md.data['Log_LogType']) if category == 'Error'
            and logtype not in ['Lickometer', 'Nosepoke']]

    except KeyError:             
      errors = None
      print 'Unable to read log'

    if errors:
      print 'Errors in %s' %fname

    try:
      warnings = [(date, note, logtype) for date, note, category, logtype in 
                zip(md.data['Log_DateTime'], md.data['Log_LogNotes'],
                md.data['Log_LogCategory'],
                md.data['Log_LogType']) if note.startswith('Unregistered tag')
                or note.startswith('Presence signal')]

    except KeyError:
      warnings = None

    if warnings:
      print '%d warnings in %s' %(len(warnings), fname) 
      notes = [note for _, note, _ in warnings]
      for note in set(notes):
        print "%s: %d time(s)" %(note, notes.count(note))
      

class PresenceLogAnalyzer(ILogAnalyzer):
  """Analyze 'presence' errors"""
  def __init__(self):
    self.notes = '\n'.join(['Generated by PresenceLogAnalyzer', '', ''])
    self.fin_bin = 3600. # Final bins: 1 hour
  
  def __call__(self, md):
    results = []
    for cage in md.cages:
      for corner in ['1', '2', '3', '4']:
        events = [tm for tm, typ, cn, cg in zip(
                  md.data['Log_DateTime'], md.data['Log_LogNotes'], md.data['Log_Corner'],
                  md.data['Log_Cage'])
                  if typ.startswith('Presence signal') and cn == corner
                  and cg == cage]
        if len(events) > 0:
          # print cage, corner, len(events)
          tt = np.array(map(convertTime, events))
          tt_orig = tt.copy()
          tds = np.diff(tt)  
    
          # # Wywalanie jesli sa co najmniej 3 w czasie ponizej minuty
          # idcs = np.zeros_like(tt)
          # for idx, there, dthere in zip(range(len(tt)-1), tt[:-1], tds):
          #     if dthere < 60.:
          #         # print idx, there, dthere
          #         idx2 = np.where((tt >= there)&(tt < there + 60.))[0]
          #         # print idx, idx2
          #         if len(idx2) >= 3:
          #             idcs[idx2] = 1 
          # print idcs
          # tt = np.delete(tt, np.where(idcs))
      
          # Wywalamy blizsze siebie niz 30 s
          idcs = np.zeros_like(tt)
          idcs[tds < 30.] = 1
          tds = np.r_[np.nan, tds]
          idcs[tds < 30.] = 1
          tt = np.delete(tt, np.where(idcs))
          
          if len(tt) > 0:  
            # Wywalamy jesli izolowany
            tds = np.diff(tt)
            idcs = np.zeros_like(tt) 
            idcs[0] += 0.5
            idcs[-1] += 0.5
            idcs[tds > 1800.] += 0.5
            tds = np.r_[np.nan, tds] 
            idcs[tds > 1800.] += 0.5          
            tt = np.delete(tt, np.where(idcs > 0.75))

          if len(tt) > 0:
            # Pomijamy jesli <= 4 bledy w dobie
            long_bins = np.arange(tt.min(), 
                   tt.max() + 25. * 3600., 24 * 3600.)
            hist = np.histogram(tt, bins=long_bins)[0]
            if np.all(hist <= 4):
              pass

            else:
              # print cage, corner, 'Zostalo ', len(tt)
              bins = np.arange(tt.min(), 
                     tt.max() + self.fin_bin + 1., self.fin_bin) 
              hist = np.histogram(tt, bins=bins)[0]  
              idcs = mmlab.contiguous_regions(hist)
              for tstartidx, tstopidx in idcs:
                tstart = bins[tstartidx]
                tstop = bins[tstopidx]
                results.append(ExcludeMouseData(starttime=tstart,
                        endtime=tstop, logtype='Presence',
                        cage=cage, corner=corner, 
                        notes=str(sum(hist[tstartidx:tstopidx])) 
                        + ' cases. ' + self.notes))

    return results                    
